## Swift Memory Management

<br/>

Swift는 ARC Automatic Reference Counting (자동참조카운팅)를 사용하기 때문에

매 참조 타입의 오브젝트를 명시적, 개별적으로 메모리 관리 하지 않아도 된다.

하지만 ARC를 사용하더라도 메모리 관리에 오류가 발생할 수 있고 코코아 메모리 관리 

시스템이 메모리 관리에 실패할 수 있다. 

<br/>

##### 코코아 메모리 관리 법칙

레퍼런스 타입 메모리가 관리돼야 하는 이유는 레퍼런스 타입 오브젝트가 참조하는 것은

포인터이기 때문이다. 

객체가 생성되면 메모리를 확보하고 소멸되면 메모리를 풀어주는데 실제 객체는 이 메모리를

가리키고 있다.

객체가 인스턴스화되면 메모리가 확보된다.

객체는 자신을 참조하는 다른 객체가 없을 경우에는 확실히 소멸해야 한다. 포인터가 없는

객체는 쓸모가 없다. 메모리를 점유하고 있지만 이를 참조하거나 참조를 얻으려는 객체가

없는 경우다. 이런 현상을 메모리 누수leak 라고 한다. 대다수의 컴퓨터 언어는 이 문제를 

가비지 컬렉션으로 해결하지만 (주기적으로 모든 객체를 살펴보면서 포인터가 없는 객체를 

소멸시켜 메모리 누수를 방지한다.) 하지만 가비지 컬렉션은 메모리가 제한적이고 프로세서가

상대적으로 느리기 때문에 iOS 디바이스에서는 비용이 많이 든다.

그래서 iOS 메모리는 각자의 방법으로 어느 정도의 수작업을 통해 관리 돼야 한다. 

**오브젝트 각각은 더 이상 필요가 없을 때 '정확히' 소멸 돼야 한다.**

객체 여러 개가 동일한 객체인 하나의 포인터(레퍼런스)를 가질 수 있다. 

어떤 객체가 참조하고 있는 객체를 즉시 소멸하라고 요청한다면 그 객체를 참조하고 있는

객체는 아무것도 가리키지 않는 포인터를 가지고 있게 된다. 

포인터 뒤에서 소멸된 객체를 가진 포인터는 **댕글링 포인터** dangling pointer 라고 한다. 

아무것도 가리키지 않는 포인터를 갖고 있는 객체가 지속적으로 소멸된 객체에게 메세지를

보내기 위해 댕글링 포인터를 계속 사용한다면 앱은 충돌하게 된다.

댕글린 포인터와 메모리 누수를 방지하기 위해 모든 레퍼런스 타입 오브젝트를 관리하는

숫자에 기반한 수작업 메모르 관리 정책이 있는데 이를 **리테인 카운트** retain count 라고

한다. 다른 객체는 참조하는 객체의 리테인 카운트를 증가시키거나 감소시킬 수 있다.

객체 리테인 카운트가 계속 양수로 유지되는 동안에 객체는 계속 살아있다. 

다른 객체에게 스스로 소멸하도록 직접 요청할 수 있는 객체는 없다. 객체 리테인 카운트가

0이 되자마자 자동으로 소멸된다.

지속적으로 a객체가 필요한 모든 객체는 a의 리테인 카운트를 증가시켜야 하고 지속적으로

a를 더 이상 참조하지 않을 때마다 카운트를 감소시켜야 한다. 모든 객체가 이 규칙에 따라서

잘 동작된다면 수작업 메모리 관리 문제는 효과적으로 해결된다.



<br/>

<br/>

